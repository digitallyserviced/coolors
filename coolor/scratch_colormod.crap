"#000000" "#c51e14" "#1dc121" "#c7c329" "#0a2fc4" "#c839c5" "#20c5c6" "#c7c7c7" "#686868" "#fd6f6b" "#67f86f" "#fffa72" "#6a76fb" "#fd7cfc" "#68fdfe" "#ffffff"
	// newFrame.AddText(fcc.Html(), false, tview.AlignCenter, GetTheme().InfoLabel)
	// cci.Flex.SetBorderPadding(2,2,2,2)
		// infoTextView.SetBorderPadding(1,0,0,0)
		// infoTextView.SetBorderColor(theme.SidebarBackground)
		// infoTextView.SetBorderPadding(1,1,0,0)
		// infoTextView.SetBackgroundColor(theme.SidebarBackground)
	// infoTextView.SetBorderPadding(1,1,0,0)
	// gridView.AddItem(NewInfoTextView("[green:#21252B:b] hex [-:-:-]", true), 1, 0, 1, 1, 3, 3, false)
	// gridView.AddItem(NewInfoTextView(fmt.Sprintf("[yellow:-:b] %s [-:-:-]", fcc.Html()), false), 1, 1, 1, 2, 3, 3, false)
	// gridView.AddItem(NewInfoTextView("[green:-:b] hsl [-:-:-]", true), 1, 3, 1, 1, 3, 3, false)
	// gridView.AddItem(NewInfoTextView(, false), 1, 4, 1, 2, 3, 3, false)
	// gridView.AddItem(MakeBoxItem("",""), 2, 0, 1, 6, 0, 0, false)

// type CoolorColorInfoData
	// cci.gridView.SetGap(1, 0)
	// cci.gridView.SetMinSize(3, 3)
	// cci.gridView.SetBorders(true)

	// cci.infoView.Clear()
	// cci.infoView.AddItem(topbar, 0, , false)
	// cci.infoView.AddItem(MakeBoxItem("", ""), 0, 6, false)
	// fmt.Println()
	// topbar.SetTitle(tview.TranslateANSI(color.Render(fmt.Sprintf("%s", ccci.String()))))
	// topbar.SetRegions(true)
	// topbar.SetMaxLines(1)
	// topbar.SetBorder(true)
	// topbar.SetBorderColor(theme.SidebarBackground)
	// topbar.SetBackgroundColor(tcell.GetColor("#21252B"))
	// topbar.SetTitleAlign(tview.AlignCenter)
	// len(ColorModNames) 🮋🮒🮑🮐🮆🮔🮕🮖🮗🮟🮞🮝🮜🮘🮙🮚🮱🮴🮽🮾🮿🯄
	//                                      🬻 🬺 🬹 🬸 🬷 🬶
	//
	//             🬎🬎🬎🬆                       🬵 🬴 🬳 🬲 🬱 🬰
	//
	//             🬹🬹🬹🬱                       🬯 🬮 🬭 🬬 🬫 🬪
	//
	//                                    🬩 🬨 🬧 🬦 🬥 🬤
	//
	//             🬎🬎🬎🬬                    🬣 🬢 🬡 🬠 🬟 🬞
	//                🮈 🮊 🮋 🮌
	//             🬹🬹🬹🬻                    🬝 🬜 🬛 🬚 🬙 🬘
	//
	//             🬎🬎🬎🬬                    🬗 🬖 🬕 🬔 🬓 🬒
	//                
	//             🬹🬹🬹🬻                    🬑 🬐 🬏🬊🬎🬆 🬍 🬌
	//
	//                                     🬋 🬊 🬉 🬈 🬇 🬆
	//
	//                                     🬅 🬄 🬃 🬂 🬁 🬀
	//                                    // 🬼 🬽 🬾 🬿 🭀 🭁 🭂 🭃 🭄 🭅 🭆 🭇 🭈 🭉 🭊 🭋 🭌 🭍 🭎 🭏 🭐 🭑 🭒 🭓 🭔 🭕 🭖 🭗 🭘 🭙 🭚 🭛 🭜 🭝 🭞 🭟 🭠 🭡 🭢 🭣 🭤 🭥 🭦 🭧
	//🭨 🭩 🭪 🭫 🭬 🭭 🭮 🭯 🭰 🭱 🭲 🭳 🭴 🭵 🭶 🭷 🭸 🭹 🭺 🭻 🭼 🭽 🭾 🭿 🮀 🮁 🮂 🮃 🮄 🮅 🮆 🮇 🮈 🮉 🮊 🮋 🮌 🮍 🮎 🮏 🮐 🮑 🮒 🮔 🮕 🮖 🮗 🮘 🮙 🮚 🮛 🮜 🮝 🮞 🮟 🮠 🮡 🮢 🮣 🮤 🮥 🮦 🮧 🮨 🮩 🮪 🮫 🮬 🮭 🮮 🮯 🮰 🮱 🮲 🮳 🮴 🮵 🮶 🮷 🮸 🮹 🮺 🮻 🮼 🮽 🮾 🮿 🯀 🯊 🯰 🯱 🯲 🯳 🯴 🯵 🯶 🯷 🯸 🯹
	// 🬼  🬽 🬾 🬿 🭀
	// 🭌 🭍 🭎 🭏 🭐 🭑
	// 🭗 🭘 🭙 🭚 🭛 🭜 🭝 🭞 🭟 🭠 🭡
	//    🬼
	// 🭌
	// 🭡
	// 🭜
// len(ColorModNames) 
// func (cm *ChannelMod) GetStatus(cc CoolColor) string {
//   return cm.FormatChannelValue(cc)
// }

// func (cm *ChannelMod) GetStatus(cc CoolColor) string,string {
//   return cm.FormatChannelValue(cc)
// }
type ChannelMod struct {
	cmo *ChannelModOptions
	FormatChannelValue func(cc CoolColor) string
	GetChannelValue    func(cc CoolColor) float64
	SetChannelValue    func(cc CoolColor, value float64) (CoolColor, bool)
	// GetName         func() string
	// ModPct          func(cc CoolColor, value float64, negative bool) CoolorColor
	// Min             func() float64
	// Max             func() float64
}

// var SatMod *ColorMod = NewColorMod("Sat", *satFunc(0.0, 1.0), 0.05, 10)

// func satFunc(min, max float64) *ChannelMod {
// 	cm := &ChannelMod{
// 		GetChannelValue: func(cc CoolColor) float64 {
// 			_, s, _ := cc.GetCC().HSL()
// 			return s
// 		},
// 		SetChannelValue: func(cc CoolColor, value float64) CoolorColor {
// 			h, s, l := cc.GetCC().HSL()
// 			value = clamp(value, min, max)
// 			s = value
// 			hsl := colorful.Hsl(h, s, l)
// 			ccm := &CoolColorMod{&hsl}
// 			return *ccm.GetCC()
// 		},
// 	}
// 	return cm
// }

// func (cmas *ColorModActions) String() string {
//   // str
//   return fmt.Sprintf("%s", ColorModActionStrings[cma.Function])
// }

func (cm *ColorModifier) updateState(noUpdateColor bool) {
	// if !noUpdateColor {
	// 	cm.mid = cm.GetChannelValue(&cm.current)
	// }
	// increment := cm.increment
	// incrs := float64(1.0 / increment)

  // cm.increment = cm.minIncrValue
  // cm.increment = cm.increment * ((cm.size / cm.minIncrValue) + 2)
  // dump.P("incr: ,", cm.increment)
  // cm.increment = i
  // cm.increment := cm.minIncrValue // / cm.max
  // cm.increment = increment
	// sizeIncrs := float64(1.0 / cm.size)
	// count := 1.0 / sizeIncrs
	// split := incrs / 2
	// diff := (split * increment)
	// cm.above = math.Floor(diff/increment) - 1
	// cm.below = math.Floor(diff/increment) - 1
	// cm.increment = increment
	// cm.count = count
	// cm.diff = diff
}
// func (cm *ColorMod) makeGrad(diff float64, invert bool) []colorful.Color {
// 	endcc := cm.chm.Mod(&cm.current, diff, false)
// 	// fmt.Println(endcc.GetCC())
// 	cg := colorgrad.NewGradient()
// 	if invert {
// 		cg.HtmlColors(
// 			endcc.Html(), cm.current.Html(),
// 		)
// 	} else {
// 		cg.HtmlColors(
// 			cm.current.Html(), endcc.Html(),
// 		)
// 	}
// 	cg.Mode(colorgrad.BlendLinearRgb).Build()
// 	grad, _ := cg.Build()
// 	return grad.ColorfulColors(uint(cm.above))
//
// }

// func (cm *ColorMod) Below() []CoolorColor {
// 	// num := clamp(cm.diff*cm.chm.Max(), cm.chm.Min(), cm.chm.Max())
// 	return cm.makeGrad(false)
// }
//
// func (cm *ColorMod) Above() []CoolorColor {
// 	// num := clamp(cm.diff*cm.chm.Max(), cm.chm.Min(), cm.chm.Max())
// 	return cm.makeGrad(true)
// 	// return cm.makeGrad(math.Abs(num), true)
// }

